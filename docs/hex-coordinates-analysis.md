# Анализ Системы Координат для LLM-Генерации Карт

## Обзор

Данный документ сравнивает текущую реализацию гексагональной сетки с рекомендациями по использованию LLM для автоматической генерации карт по текстовому описанию.

**Важно**: Редактор карт выделен в отдельный проект **"Medieval Hexagon Map Editor"** (ранее `editor-nextjs`), который полностью независим от основного игрового проекта. Все изменения системы координат применяются только к редактору карт.

## Текущая Реализация

### Система Координат: **Odd-R Offset**

Текущая реализация использует систему координат **odd-r offset** (смещенные координаты с нечетными рядами):

```178:216:Medieval Hexagon Map Editor/lib/game/Map.ts
  // Get neighboring coordinates for hexagonal grid (odd-r offset coordinates)
  getNeighborCoordinates(x: number, y: number): Array<{ x: number; y: number }> {
    const neighbors: Array<{ x: number; y: number }> = []

    // Hexagonal grid neighbors (odd-r offset coordinates)
    let directions: Array<{ dx: number; dy: number }>
    if (y % 2 === 0) {
      // Even rows
      directions = [
        { dx: 1, dy: 0 },   // East
        { dx: 1, dy: -1 },  // North East
        { dx: 0, dy: -1 },  // North West
        { dx: -1, dy: 0 },  // West
        { dx: 0, dy: 1 },   // South West
        { dx: 1, dy: 1 },   // South East
      ]
    } else {
      // Odd rows
      directions = [
        { dx: 1, dy: 0 },    // East
        { dx: 0, dy: -1 },   // North East
        { dx: -1, dy: -1 },  // North West
        { dx: -1, dy: 0 },   // West
        { dx: -1, dy: 1 },   // South West
        { dx: 0, dy: 1 },    // South East
      ]
    }

    for (const dir of directions) {
      const nx = x + dir.dx
      const ny = y + dir.dy

      if (this.isValidCoordinate(nx, ny)) {
        neighbors.push({ x: nx, y: ny })
      }
    }

    return neighbors
  }
```

**Характеристики:**
- Координаты: `(x, y)` - прямоугольная сетка
- Соседство: Зависит от четности ряда (y % 2)
- Сериализация: Формат `"x,y"` в JSON

### Проблемы Текущей Реализации

#### 1. Неправильный Расчет Расстояния

В текущей реализации `Medieval Hexagon Map Editor/lib/game/Hex.ts` отсутствует метод для расчета расстояния между гексами. Если бы он был, то использовал бы манхэттенское расстояние для квадратной сетки, что неверно для гексагональной сетки.

**Проблема**: В гексагональной сетке расстояние должно учитывать геометрию шестиугольников и использовать специальную формулу для осевых координат.

#### 3. Сложность для LLM

Offset координаты требуют знания четности ряда для определения соседей, что усложняет логику для LLM:
- Нужно помнить: "если y четное, то соседи одни, если нечетное - другие"
- Это увеличивает вероятность ошибок при генерации

## Рекомендуемый Подход (для LLM)

### Система Координат: **Осевые Координаты (Axial Coordinates)**

Рекомендуется использовать **осевые координаты** `(q, r)` для передачи через текстовый API:

**Преимущества:**
1. **Простота для JSON**: Две оси идеально ложатся в структуру JSON
2. **Единообразие**: Соседи всегда вычисляются одинаково, независимо от позиции
3. **Математическая ясность**: Прямая формула расстояния без условных операторов

### Формула Расстояния в Осевых Координатах

Для расчета расстояния между двумя гексами в осевых координатах используется формула:

```
distance(a, b) = (|a.q - b.q| + |a.q + a.r - b.q - b.r| + |a.r - b.r|) / 2
```

**Альтернативная формула через кубические координаты:**

Для математических операций можно использовать кубические координаты `(q, r, s)`, где всегда соблюдается условие `q + r + s = 0`.

Расстояние в кубических координатах:
```
distance(a, b) = (|a.q - b.q| + |a.r - b.r| + |a.s - b.s|) / 2
```

Но так как `s = -(q + r)`, формула упрощается до:
```
distance(a, b) = max(|a.q - b.q|, |a.r - b.r|, |a.q + a.r - b.q - b.r|)
```

### Соседи в Осевых Координатах

Соседи гекса в осевых координатах всегда одинаковы, независимо от позиции:

```javascript
const HEX_DIRECTIONS = [
  { q: 1, r: 0 },   // East
  { q: 1, r: -1 },  // North East
  { q: 0, r: -1 },  // North West
  { q: -1, r: 0 },  // West
  { q: -1, r: 1 },  // South West
  { q: 0, r: 1 }    // South East
]

function getNeighbor(hex, direction) {
  return {
    q: hex.q + direction.q,
    r: hex.r + direction.r
  }
}
```

## Сравнительная Таблица

| Характеристика | Текущая (Odd-R Offset) | Рекомендуемая (Axial) |
|----------------|------------------------|----------------------|
| **Координаты** | `(x, y)` - прямоугольные | `(q, r)` - осевые |
| **Соседство** | Зависит от четности y | Всегда одинаково |
| **Расстояние** | ❌ Неправильное (Manhattan) | ✅ Правильная формула |
| **Сложность для LLM** | Высокая (условная логика) | Низкая (прямая формула) |
| **JSON структура** | `"x,y"` | `{"q": q, "r": r}` |
| **Конвертация** | Требуется для вычислений | Прямое использование |

## Рекомендации по Улучшению

### ✅ Решение: Полный Переход на Осевые Координаты

**Принято решение о полном переходе на осевые координаты `(q, r)` для оптимальной совместимости с LLM.**

Это означает:
- **Вся внутренняя логика** переходит на осевые координаты
- **Все классы** (`Hex`, `Map`) используют `q, r` вместо `x, y`
- **Сериализация** использует осевые координаты по умолчанию
- **Рендеринг** конвертирует осевые координаты в экранные координаты при отрисовке

**Преимущества полного перехода:**
- ✅ Единая система координат во всём проекте
- ✅ Оптимальная совместимость с LLM из коробки
- ✅ Упрощённая логика (нет условных операторов для соседей)
- ✅ Правильная формула расстояния
- ✅ Нет необходимости в конвертации на границах

### 1. Изменить Класс Hex

Заменить `x, y` на `q, r`:

```typescript
export class Hex {
  q: number  // Было: x
  r: number  // Было: y
  terrain: TerrainType
  // ... остальные поля

  constructor(q: number, r: number, terrain: TerrainType = TERRAIN_TYPES.PLAINS) {
    this.q = q
    this.r = r
    this.terrain = terrain
  }

  // Правильная формула расстояния в осевых координатах
  distanceTo(otherHex: Hex): number {
    return (Math.abs(this.q - otherHex.q) + 
            Math.abs(this.q + this.r - otherHex.q - otherHex.r) + 
            Math.abs(this.r - otherHex.r)) / 2
  }

  // Альтернатива через кубические координаты (более эффективно)
  distanceToCubic(otherHex: Hex): number {
    const thisS = -(this.q + this.r)
    const otherS = -(otherHex.q + otherHex.r)
    return (Math.abs(this.q - otherHex.q) + 
            Math.abs(this.r - otherHex.r) + 
            Math.abs(thisS - otherS)) / 2
  }
}
```

### 2. Изменить Класс Map

Обновить все методы для работы с `q, r`:

```typescript
export class Map {
  width: number  // Максимальная q координата
  height: number // Максимальная r координата
  hexes: Map<string, Hex[]> // Ключ: "q,r"

  constructor(width: number, height: number) {
    this.width = width
    this.height = height
    this.hexes = new Map()
  }

  getKey(q: number, r: number): string {
    return `${q},${r}`
  }

  isValidCoordinate(q: number, r: number): boolean {
    // Проверка границ (может потребоваться адаптация под форму карты)
    return q >= 0 && q < this.width && r >= 0 && r < this.height
  }

  getNeighborCoordinates(q: number, r: number): Array<{ q: number; r: number }> {
    // Единообразное вычисление соседей - без условий!
    const HEX_DIRECTIONS = [
      { q: 1, r: 0 },   // East
      { q: 1, r: -1 },  // North East
      { q: 0, r: -1 },  // North West
      { q: -1, r: 0 },  // West
      { q: -1, r: 1 },  // South West
      { q: 0, r: 1 }    // South East
    ]

    return HEX_DIRECTIONS
      .map(dir => ({ q: q + dir.q, r: r + dir.r }))
      .filter(coord => this.isValidCoordinate(coord.q, coord.r))
  }
}
```

### 3. Обновить Формат Сериализации

Использовать осевые координаты как основной формат:

```json
{
  "version": "2.0",
  "format": "warlords-map",
  "metadata": {
    "name": "My Custom Map",
    "description": "A custom map description",
    "mapSize": "medium"
  },
  "map": {
    "width": 50,
    "height": 50
  },
  "hexes": {
    "0,0": [
      {
        "q": 0,
        "r": 0,
        "terrain": "PLAINS",
        "height": 0
      }
    ],
    "1,-1": [
      {
        "q": 1,
        "r": -1,
        "terrain": "FOREST",
        "height": 0
      }
    ]
  }
}
```

### 4. Утилиты для Рендеринга

Для рендеринга в Three.js потребуется конвертация осевых координат в экранные:

```typescript
// Конвертация осевых координат в экранные (для рендеринга)
function axialToPixel(q: number, r: number, hexSize: number): { x: number; y: number } {
  const x = hexSize * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r)
  const y = hexSize * (3 / 2 * r)
  return { x, y }
}
```


## План Внедрения: Полный Переход на Осевые Координаты

### Фаза 1: Подготовка и Утилиты Конвертации
- [ ] Создать `HexCoordinateConverter` класс с функциями:
  - `axialToPixel(q, r)` - для рендеринга (конвертация осевых координат в экранные)
- [ ] Добавить тесты для всех функций конвертации

### Фаза 2: Рефакторинг Класса Hex
- [ ] Изменить `Hex.ts`: `x, y` → `q, r`
- [ ] Обновить конструктор и все методы
- [ ] Реализовать правильную формулу `distanceTo()` в осевых координатах
- [ ] Добавить тесты для расстояния и соседства

### Фаза 3: Рефакторинг Класса Map
- [ ] Изменить `Map.ts`: все методы работают с `q, r`
- [ ] Обновить `getNeighborCoordinates()` - убрать условную логику (четность ряда)
- [ ] Изменить структуру хранения: `Map<string, Hex[]>` с ключом `"q,r"`
- [ ] Обновить `isValidCoordinate()` для осевых координат
- [ ] Добавить тесты для всех методов Map

### Фаза 4: Обновление Сериализации
- [ ] Обновить `MapSerializer.ts`: формат версии 2.0 с осевыми координатами
- [ ] Изменить ключи в `hexes`: `"q,r"` вместо `"x,y"`
- [ ] Обновить валидацию формата
- [ ] Обновить тесты сериализации

### Фаза 5: Обновление Рендеринга
- [ ] Обновить `MapEditor.tsx`: конвертация `q, r` → экранные координаты
- [ ] Обновить все места, где используются координаты для рендеринга
- [ ] Протестировать визуальное отображение

### Фаза 6: Обновление Документации и LLM API
- [ ] Обновить `map-file-format.md` с новым форматом
- [ ] Создать документацию для LLM с примерами генерации карт
- [ ] Добавить примеры промптов для LLM
- [ ] Обновить README с информацией о системе координат

## Выводы

1. **Текущая реализация** использует offset координаты, что усложняет работу с LLM
2. **Принято решение** о полном переходе на осевые координаты `(q, r)` для оптимальной совместимости с LLM
3. **Критично** исправить формулу расстояния - сейчас она неверна для гексагональной сетки
4. **Полный переход** обеспечит:
   - Единую систему координат во всём проекте
   - Оптимальную совместимость с LLM из коробки
   - Упрощённую логику (без условных операторов)
   - Правильные математические операции

## Риски и Меры Предосторожности

### Риски:
- **Объём работы**: Рефакторинг затронет основные классы редактора (`Hex`, `Map`, `MapSerializer`)
- **Тестирование**: Необходимо тщательное тестирование всех функций редактора карт

### Меры предосторожности:
- ✅ Тщательное тестирование на каждом этапе
- ✅ Версионирование формата файлов (версия 2.0 с осевыми координатами)

## Ссылки

- [Hexagonal Grids - Red Blob Games](https://www.redblobgames.com/grids/hexagons/)
- Формула расстояния из описания пользователя
- Текущая реализация: `Medieval Hexagon Map Editor/lib/game/Map.ts`, `Medieval Hexagon Map Editor/lib/game/Hex.ts`

